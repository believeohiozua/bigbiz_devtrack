import { useRef, useState, useEffect, useCallback } from 'react';

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}

function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var canUsePassiveEvents = (function () {
  if (typeof window === "undefined" || typeof window.addEventListener !== "function") return false;
  var passive = false;
  var options = Object.defineProperty({}, "passive", {
    // eslint-disable-next-line getter-return
    get: function get() {
      passive = true;
    }
  });

  var noop = function noop() {
    return null;
  };

  window.addEventListener("test", noop, options);
  window.removeEventListener("test", noop, options);
  return passive;
});

var DEFAULT_IGNORE_CLASS = "ignore-onclickoutside";

var hasIgnoreClass = function hasIgnoreClass(e, ignoreClass) {
  var el = e.target;

  while (el) {
    var _el$classList;

    if ((_el$classList = el.classList) === null || _el$classList === void 0 ? void 0 : _el$classList.contains(ignoreClass)) return true;
    el = el.parentElement;
  }

  return false;
};

var clickedOnScrollbar = function clickedOnScrollbar(e) {
  return document.documentElement.clientWidth <= e.clientX || document.documentElement.clientHeight <= e.clientY;
};

var getEventOptions = function getEventOptions(type) {
  return type.includes("touch") && canUsePassiveEvents() ? {
    passive: true
  } : false;
};

var useOnclickOutside = function useOnclickOutside(callback) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      refsOpt = _ref.refs,
      _ref$disabled = _ref.disabled,
      disabled = _ref$disabled === void 0 ? false : _ref$disabled,
      _ref$eventTypes = _ref.eventTypes,
      eventTypes = _ref$eventTypes === void 0 ? ["mousedown", "touchstart"] : _ref$eventTypes,
      _ref$excludeScrollbar = _ref.excludeScrollbar,
      excludeScrollbar = _ref$excludeScrollbar === void 0 ? false : _ref$excludeScrollbar,
      _ref$ignoreClass = _ref.ignoreClass,
      ignoreClass = _ref$ignoreClass === void 0 ? DEFAULT_IGNORE_CLASS : _ref$ignoreClass;

  var callbackRef = useRef(callback);

  var _useState = useState([]),
      _useState2 = _slicedToArray(_useState, 2),
      refsState = _useState2[0],
      setRefsState = _useState2[1];

  useEffect(function () {
    callbackRef.current = callback;
  }, [callback]);
  var ref = useCallback(function (el) {
    setRefsState(function (prevState) {
      return [].concat(_toConsumableArray(prevState), [{
        current: el
      }]);
    });
  }, []);
  useEffect(function () {
    if (!(refsOpt === null || refsOpt === void 0 ? void 0 : refsOpt.length) && !refsState.length) return;

    var listener = function listener(e) {
      if (hasIgnoreClass(e, ignoreClass)) return;
      var refs = refsOpt || refsState;
      var els = [];
      refs.forEach(function (_ref2) {
        var current = _ref2.current;
        if (current) els.push(current);
      });
      if (excludeScrollbar && clickedOnScrollbar(e)) return;
      if (!els.length || !els.every(function (el) {
        return !el.contains(e.target);
      })) return;
      callbackRef.current(e);
    };

    var removeEventListener = function removeEventListener() {
      eventTypes.forEach(function (type) {
        // @ts-expect-error
        document.removeEventListener(type, listener, getEventOptions(type));
      });
    };

    if (disabled) {
      removeEventListener();
      return;
    }

    eventTypes.forEach(function (type) {
      document.addEventListener(type, listener, getEventOptions(type));
    }); // eslint-disable-next-line consistent-return

    return function () {
      removeEventListener();
    };
  }, // eslint-disable-next-line react-hooks/exhaustive-deps
  [refsState, ignoreClass, excludeScrollbar, disabled, // eslint-disable-next-line react-hooks/exhaustive-deps
  JSON.stringify(eventTypes)]);
  return ref;
};

export default useOnclickOutside;
export { DEFAULT_IGNORE_CLASS };
